# -*- coding: utf-8 -*-
"""Derivative_Pricing_Group_Work_Project_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U-HEPTdQO_RkYFxGGt_RUgIexBzM7AbD

#STOCHASTIC VOLATILTY : HESTON  AND MONTE-CARLO SIMULATION  
#5. Correlation  equal to  -0.30
"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as ss

def SDE_vol(v0, kappa, theta, sigma, T, M, Ite, rand, row, cho_matrix):
    dt = T / M  # T = maturity, M = number of time steps
    v = np.zeros((M + 1, Ite), dtype=np.float64)
    v[0] = v0
    sdt = np.sqrt(dt)  # Sqrt of dt
    for t in range(1, M + 1):
        ran = np.dot(cho_matrix, rand[:, t])
        v[t] = np.maximum(
            v[t - 1]
            + kappa * (theta - np.maximum(v[t - 1], 0)) * dt
            + np.sqrt(np.maximum(v[t - 1], 0)) * sigma * ran[row] * sdt,
            0  # Ensure volatility is non-negative
        )
    return v

def Heston_paths(S0, r, v, row, cho_matrix):
    S = np.zeros((M + 1, Ite), dtype=np.float64)
    S[0] = S0
    sdt = np.sqrt(dt)
    for t in range(1, M + 1, 1):
        ran = np.dot(cho_matrix, rand[:, t])
        S[t] = S[t - 1] * np.exp((r - 0.5 * v[t]) * dt + np.sqrt(v[t]) * ran[row] * sdt)

    return S

def random_number_gen(M, Ite):
    rand = np.random.standard_normal((2, M + 1, Ite))
    return rand

v0 = 0.032
kappa_v = 1.85
sigma_v = 0.35
theta_v = 0.045
rho = -0.30
K=80
t=0
S0 = 80  # Current underlying asset price
r = 0.055  # Risk-free rate
M0 = 52  # Number of time steps in a year
T = 3/12  # Number of years
M = int(M0 * T)  # Total time steps
Ite = 10000  # Number of simulations
dt = T / M  # Length of time step

# Generating random numbers from standard normal
rand = random_number_gen(M, Ite)

# Covariance Matrix
covariance_matrix = np.zeros((2, 2), dtype=np.float64)
covariance_matrix[0] = [1.0, rho]
covariance_matrix[1] = [rho, 1.0]
cho_matrix = np.linalg.cholesky(covariance_matrix)

# Volatility process paths
V= SDE_vol(v0, kappa_v, theta_v, sigma_v, T, M, Ite, rand, 1, cho_matrix)

# Underlying price process paths
S = Heston_paths(S0, r, V, 0, cho_matrix)

def heston_call_mcP_1(S, K, r, T, t):
    payoff = np.maximum(0, S[-1, :] - K)
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average

def heston_put_mcP_1(S, K, r, T, t):
    payoff = np.maximum(0, K - S[-1, :])
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average

print("European call:", heston_call_mcP_1(S, K, r, T, 0))
print("European Put:", heston_put_mcP_1(S, K, r, T, 0))

"""#6. Correlation equal to *-0.70*"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as ss

def SDE_vol(v0, kappa, theta, sigma, T, M, Ite, rand, row, cho_matrix):
    dt = T / M  # T = maturity, M = number of time steps
    v = np.zeros((M + 1, Ite), dtype=np.float64)
    v[0] = v0
    sdt = np.sqrt(dt)  # Sqrt of dt
    for t in range(1, M + 1):
        ran = np.dot(cho_matrix, rand[:, t])
        v[t] = np.maximum(
            v[t - 1]
            + kappa * (theta - np.maximum(v[t - 1], 0)) * dt
            + np.sqrt(np.maximum(v[t - 1], 0)) * sigma * ran[row] * sdt,
            0  # Ensure volatility is non-negative
        )
    return v

def Heston_paths(S0, r, v, row, cho_matrix):
    S = np.zeros((M + 1, Ite), dtype=np.float64)
    S[0] = S0
    sdt = np.sqrt(dt)
    for t in range(1, M + 1, 1):
        ran = np.dot(cho_matrix, rand[:, t])
        S[t] = S[t - 1] * np.exp((r - 0.5 * v[t]) * dt + np.sqrt(v[t]) * ran[row] * sdt)

    return S

def random_number_gen(M, Ite):
    rand = np.random.standard_normal((2, M + 1, Ite))
    return rand

v0 = 0.032
kappa_v = 1.85
sigma_v = 0.35
theta_v = 0.045
rho = -0.70
K=80
t=0
S0 = 80  # Current underlying asset price
r = 0.055  # Risk-free rate
M0 = 52  # Number of time steps in a year
T = 3/12  # Number of years
M = int(M0 * T)  # Total time steps
Ite = 10000  # Number of simulations
dt = T / M  # Length of time step

# Generating random numbers from standard normal
rand = random_number_gen(M, Ite)

# Covariance Matrix
covariance_matrix = np.zeros((2, 2), dtype=np.float64)
covariance_matrix[0] = [1.0, rho]
covariance_matrix[1] = [rho, 1.0]
cho_matrix = np.linalg.cholesky(covariance_matrix)

# Volatility process paths
V= SDE_vol(v0, kappa_v, theta_v, sigma_v, T, M, Ite, rand, 1, cho_matrix)

# Underlying price process paths
S = Heston_paths(S0, r, V, 0, cho_matrix)

def heston_call_mcP_2(S, K, r, T, t):
    payoff = np.maximum(0, S[-1, :] - K)
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average

def heston_put_mcP_2(S, K, r, T, t):
    payoff = np.maximum(0, K - S[-1, :])
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average

print("European call:", heston_call_mcP_2(S, K, r, T, 0))
print("European Put:", heston_put_mcP_2(S, K, r, T, 0))

"""#7.Greeks in Heston Model

Delta and Gamma  for rho = -0.30
"""

import numpy as np
import matplotlib.pyplot as plt

# Define the Heston model parameters and option details
S0 = 80   # Current stock price
K = 80   # Strike price
r = 0.055   # Risk-free rate
T = 3/12      # Time to maturity
v0 = 0.032  # Initial volatility
kappa_v =1.82
theta_v = 0.045
sigma_v = 0.35
rho = -0.30

# Option details
M = 100  # Number of time steps
Ite = 10000  # Number of simulations

# Generate random numbers
rand = np.random.standard_normal((2, M + 1, Ite))

# Covariance Matrix
covariance_matrix = np.array([[1.0, rho], [rho, 1.0]])
cho_matrix = np.linalg.cholesky(covariance_matrix)

# Volatility process paths
V = SDE_vol(v0, kappa_v, theta_v, sigma_v, T, M, Ite, rand, 1, cho_matrix)

# Underlying price process paths
S = Heston_paths(S0, r, V, 0, cho_matrix)

# Calculate option price
option_price = heston_call_mcP_1(S, K, r, T, 0)

# Calculate Delta using numerical differentiation
delta_epsilon = 0.001
S_epsilon_plus = S.copy()
S_epsilon_plus[-1, :] = S[-1, :] + delta_epsilon
option_price_plus_1 = heston_call_mcP_1(S_epsilon_plus, K, r, T, 0)
option_price_plus_2=heston_put_mcP_1(S_epsilon_plus, K, r, T, 0)
delta_1 = (option_price_plus_1 - option_price) / delta_epsilon
delta_2= (option_price_plus_2 - option_price) / delta_epsilon
# Calculate Gamma using numerical differentiation
gamma_epsilon = 0.001
S_epsilon_minus = S.copy()
S_epsilon_minus[-1, :] = S[-1, :] - gamma_epsilon
gamma_1 = (delta_1) / S0
gamma_2=(option_price_plus_2 - 2 * option_price + option_price_minus_2) / S0
print("Delta for call:", delta_1)
print("Gamma for call:", gamma_1)
print("Delta for put",delta_2/10000)
print("Gamma for put",gamma_2)

"""Delta and Gamma for  rho = -0.70"""

import numpy as np
import matplotlib.pyplot as plt

# Define the Heston model parameters and option details
S0 = 80   # Current stock price
K = 80   # Strike price
r = 0.055   # Risk-free rate
T = 3/12      # Time to maturity
v0 = 0.032  # Initial volatility
kappa_v =1.82
theta_v = 0.045
sigma_v = 0.35
rho = -0.70

# Option details
M = 100  # Number of time steps
Ite = 10000  # Number of simulations

# Generate random numbers
rand = np.random.standard_normal((2, M + 1, Ite))

# Covariance Matrix
covariance_matrix = np.array([[1.0, rho], [rho, 1.0]])
cho_matrix = np.linalg.cholesky(covariance_matrix)

# Volatility process paths
V = SDE_vol(v0, kappa_v, theta_v, sigma_v, T, M, Ite, rand, 1, cho_matrix)

# Underlying price process paths
S = Heston_paths(S0, r, V, 0, cho_matrix)

# Calculate option price
option_price = heston_call_mcP_1(S, K, r, T, 0)

# Calculate Delta using numerical differentiation
delta_epsilon = 0.001
S_epsilon_plus = S.copy()
S_epsilon_plus[-1, :] = S[-1, :] + delta_epsilon
option_price_plus_1 = heston_call_mcP_1(S_epsilon_plus, K, r, T, 0)
option_price_plus_2=heston_put_mcP_1(S_epsilon_plus, K, r, T, 0)
delta_1 = (option_price_plus_1 - option_price) / delta_epsilon
delta_2= (option_price_plus_2 - option_price) / delta_epsilon
# Calculate Gamma using numerical differentiation
gamma_epsilon = 0.001
S_epsilon_minus = S.copy()
S_epsilon_minus[-1, :] = S[-1, :] - gamma_epsilon
gamma_1 = (delta_1) / S0
gamma_2=(option_price_plus_2 - 2 * option_price + option_price_minus_2) / S0
print("Delta for call:", delta_1)
print("Gamma for call:", gamma_1)
print("Delta for put",-delta_2/10000)
print("Gamma for put",-gamma_2)

"""#Team Member B: Jump Modeler: Merton Model

8(a) Jump instensity of 0.75
"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as ss

lamb = 0.75  # Lambda of the model
mu = -0.5  # Mu
delta = 0.25  # Delta

r = 0.055  # Risk-free rate
sigma = 0.35  # Volatility
T = 3/12  # Maturity/time period (in years)
S0 = 80  # Current Stock Price

Ite = 10000  # Number of simulations (paths)
M = 50  # Number of steps
dt = T / M  # Time-step

SM = np.zeros((M + 1, Ite))
SM[0] = S0

# rj
rj = lamb * (np.exp(mu + 0.5 * delta**2) - 1)

# Random numbers
z1 = np.random.standard_normal((M + 1, Ite))
z2 = np.random.standard_normal((M + 1, Ite))
y = np.random.poisson(lamb * dt, (M + 1, Ite))

for t in range(1, M + 1):
    SM[t] = SM[t - 1] * (
        np.exp((r - rj - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * z1[t])
        + (np.exp(mu + delta * z2[t]) - 1) * y[t]
    )
    SM[t] = np.maximum(
        SM[t], 0.00001
    )  # To ensure that the price never goes below zero!

# Define the function outside the loop
def merton_call_mc(S, K, r, T, t):
    payoff = np.maximum(0, S[-1, :] - K)
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average

def merton_put_mc(S, K, r, T, t):
    payoff = np.maximum(0, K-S[-1, :] )
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average

# Example usage
K = 80  # Strike price
t = 0  # Current time

# Calculate the call option price
call_option_price = merton_call_mc(SM, K, r, T, t)
put_option_price= merton_put_mc(SM,K,r,T,t)
print("Merton Call Option Price:", call_option_price)
print("Merton Put option Price :",put_option_price)

"""(b) Jumper intensity of 0.25

9.Jump intensity of 0.25
"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as ss

lamb = 0.25  # Lambda of the model
mu = -0.5 # Mu
delta = 0.25  # Delta

r = 0.055  # Risk-free rate
sigma = 0.35  # Volatility
T = 3/12 # Maturity/time period (in years)
S0 = 80  # Current Stock Price

Ite = 10000  # Number of simulations (paths)
M = 50  # Number of steps
dt = T / M  # Time-step

SM = np.zeros((M + 1, Ite))
SM[0] = S0

# rj
rj = lamb * (np.exp(mu + 0.5 * delta**2) - 1)

# Random numbers
z1 = np.random.standard_normal((M + 1, Ite))
z2 = np.random.standard_normal((M + 1, Ite))
y = np.random.poisson(lamb * dt, (M + 1, Ite))

for t in range(1, M + 1):
    SM[t] = SM[t - 1] * (
        np.exp((r - rj - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * z1[t])
        + (np.exp(mu + delta * z2[t]) - 1) * y[t]
    )
    SM[t] = np.maximum(
        SM[t], 0.00001
    )  # To ensure that the price never goes below zero!

# Define the function outside the loop
def merton_call_mc(S, K, r, T, t):
    payoff = np.maximum(0, S[-1, :] - K)
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average

def merton_put_mc(S, K, r, T, t):
    payoff = np.maximum(0, K-S[-1, :] )
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average
# Example usage
K = 80  # Strike price
t = 0  # Current time

# Calculate the call option price
call_option_price = merton_call_mc(SM, K, r, T, t)
put_option_price= merton_put_mc(SM,K,r,T,t)
print("Merton Call Option Price:", call_option_price)
print("Merton Put option Price :",put_option_price)

"""10."""

import numpy as np
import matplotlib.pyplot as plt

# Merton jump-diffusion model parameters
lamb = 0.75  # Lambda of the model
mu = -0.5  # Mu
delta = 0.25  # Delta

# Option parameters
r = 0.055  # Risk-free rate
sigma = 0.35  # Volatility
T = 3/12  # Maturity/time period (in years)
S0 = 80  # Current Stock Price
K = 80 # Strike Price

Ite = 10000  # Number of simulations (paths)
M = 50  # Number of steps
dt = T / M  # Time-step

SM = np.zeros((M + 1, Ite))
SM[0] = S0

# rj
rj = lamb * (np.exp(mu + 0.5 * delta**2) - 1)

# Random numbers
z1 = np.random.standard_normal((M + 1, Ite))
z2 = np.random.standard_normal((M + 1, Ite))
y = np.random.poisson(lamb * dt, (M + 1, Ite))

# Generate stock price paths
for t in range(1, M + 1):
    SM[t] = SM[t - 1] * (
        np.exp((r - rj - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * z1[t])
        + (np.exp(mu + delta * z2[t]) - 1) * y[t]
    )
    SM[t] = np.maximum(SM[t], 0.00001)  # To ensure that the price never goes below zero!

# Calculate option price
option_price = merton_call_mc(SM, K, r, T, 0)

# Calculate Delta using numerical differentiation
delta_epsilon = 0.001
SM_epsilon_plus = SM.copy()
SM_epsilon_plus[-1, :] = SM[-1, :] + delta_epsilon
option_price_plus = merton_call_mc(SM_epsilon_plus, K, r, T, 0)
delta = (option_price_plus - option_price) / delta_epsilon

# Calculate Gamma using numerical differentiation
gamma_epsilon = 0.001
SM_epsilon_minus = SM.copy()
SM_epsilon_minus[-1, :] = SM[-1, :] - gamma_epsilon
option_price_minus = merton_call_mc(SM_epsilon_minus, K, r, T, 0)
gamma = (option_price_plus - 2 * option_price + option_price_minus) / (gamma_epsilon ** 2)

print("Delta:", delta)
print("Gamma:", gamma)

"""Delta and Gamma  for intensity  = 0.25"""

import numpy as np
import matplotlib.pyplot as plt

# Merton jump-diffusion model parameters
lamb = 0.25  # Lambda of the model
mu = -0.5 # Mu
delta = 0.25  # Delta

# Option parameters
r = 0.055  # Risk-free rate
sigma = 0.35  # Volatility
T = 3/12  # Maturity/time period (in years)
S0 = 80  # Current Stock Price
K = 80  # Strike Price

Ite = 10000  # Number of simulations (paths)
M = 50  # Number of steps
dt = T / M  # Time-step

SM = np.zeros((M + 1, Ite))
SM[0] = S0

# rj
rj = lamb * (np.exp(mu + 0.5 * delta**2) - 1)

# Random numbers
z1 = np.random.standard_normal((M + 1, Ite))
z2 = np.random.standard_normal((M + 1, Ite))
y = np.random.poisson(lamb * dt, (M + 1, Ite))

# Generate stock price paths
for t in range(1, M + 1):
    SM[t] = SM[t - 1] * (
        np.exp((r - rj - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * z1[t])
        + (np.exp(mu + delta * z2[t]) - 1) * y[t]
    )
    SM[t] = np.maximum(SM[t], 0.00001)  # To ensure that the price never goes below zero!

# Calculate option price
option_price = merton_call_mc(SM, K, r, T, 0)

# Calculate Delta using numerical differentiation
delta_epsilon = 0.001
SM_epsilon_plus = SM.copy()
SM_epsilon_plus[-1, :] = SM[-1, :] + delta_epsilon
option_price_plus = merton_call_mc(SM_epsilon_plus, K, r, T, 0)
delta = (option_price_plus - option_price) / delta_epsilon

# Calculate Gamma using numerical differentiation
gamma_epsilon = 0.001
SM_epsilon_minus = SM.copy()
SM_epsilon_minus[-1, :] = SM[-1, :] - gamma_epsilon
option_price_minus = merton_call_mc(SM_epsilon_minus, K, r, T, 0)
gamma = (option_price_plus - 2 * option_price + option_price_minus) / (gamma_epsilon ** 2)

print("Delta:", delta)
print("Gamma:", gamma)

"""#Team Member C: Model Validator

#Heston model

11(a) Call and parity rho =
"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as ss

"""
The call-put parity
C_t + K*e^(r*T)= P_t +S_0
"""
C_t1= heston_call_mcP_1(S, K, r, T, 0)# Call option for heston model for rho = -0.30
P_t1 =heston_put_mcP_1(S, K, r, T, 0)#Put option for heston  model for rho = - 0.30
C_t2=heston_call_mcP_2(S, 90, 0.05, 1, 0)#Call option for heeston model for rho = -0.70
P_t2=heston_put_mcP_2(S, K, r, T, 0)#Put option for heston model for  rho = -0.70

A=C_t1+ K*np.exp(r*T)
B= P_t1 +S0
X=C_t2 +K*np.exp(r*T)
Y=P_t2 + S0

if A > B :
  print ("LHS is greater than the RHS")
elif A == B :
  print("Put-Call parity holds")
else:
  print("RHS is greater than LHS")

print(A)
print(B)

"""11(b) Call and parity for rho ="""

import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as ss

"""
The call-put parity
C_t + K*e^(r*T)= P_t +S_0
"""
C_t1= heston_call_mcP_1(S, K, r, T, 0)# Call option for heston model for rho = -0.30
P_t1 =heston_put_mcP_1(S, K, r, T, 0)#Put option for heston  model for rho = - 0.30
C_t2=heston_call_mcP_2(S, 90, 0.05, 1, 0)#Call option for heeston model for rho = -0.70
P_t2=heston_put_mcP_2(S, K, r, T, 0)#Put option for heston model for  rho = -0.70

X=C_t2 +K*np.exp(r*T)
Y=P_t2 + S0

if X > Y :
  print ("LHS is greater than the RHS")
elif X == Y :
  print("Put-Call parity holds")
else:
  print("RHS is greater than LHS")

print(X)
print()

"""#Heston Model and Merton Model

12(a) Heston Model
"""

moneyness_values = [0.85, 0.90, 0.95, 1.0, 1.05, 1.10]
K_strikes = [S0 / m for m in moneyness_values]

import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as ss

def SDE_vol(v0, kappa, theta, sigma, T, M, Ite, rand, row, cho_matrix):
    dt = T / M  # T = maturity, M = number of time steps
    v = np.zeros((M + 1, Ite), dtype=np.float64)
    v[0] = v0
    sdt = np.sqrt(dt)  # Sqrt of dt
    for t in range(1, M + 1):
        ran = np.dot(cho_matrix, rand[:, t])
        v[t] = np.maximum(
            v[t - 1]
            + kappa * (theta - np.maximum(v[t - 1], 0)) * dt
            + np.sqrt(np.maximum(v[t - 1], 0)) * sigma * ran[row] * sdt,
            0  # Ensure volatility is non-negative
        )
    return v

def Heston_paths(S0, r, v, row, cho_matrix):
    S = np.zeros((M + 1, Ite), dtype=np.float64)
    S[0] = S0
    sdt = np.sqrt(dt)
    for t in range(1, M + 1, 1):
        ran = np.dot(cho_matrix, rand[:, t])
        S[t] = S[t - 1] * np.exp((r - 0.5 * v[t]) * dt + np.sqrt(v[t]) * ran[row] * sdt)

    return S

def random_number_gen(M, Ite):
    rand = np.random.standard_normal((2, M + 1, Ite))
    return rand

v0 = 0.032
kappa_v = 1.82
sigma_v = 0.35
theta_v = 0.045
rho = -0.75
t=0
S0 = 80  # Current underlying asset price
r = 0.055  # Risk-free rate
M0 = 50  # Number of time steps in a year
T = 1  # Number of years
M = int(M0 * T)  # Total time steps
Ite = 10000  # Number of simulations
dt = T / M  # Length of time step

# Generating random numbers from standard normal
rand = random_number_gen(M, Ite)

# Covariance Matrix
covariance_matrix = np.zeros((2, 2), dtype=np.float64)
covariance_matrix[0] = [1.0, rho]
covariance_matrix[1] = [rho, 1.0]
cho_matrix = np.linalg.cholesky(covariance_matrix)

# Volatility process paths
V= SDE_vol(v0, kappa_v, theta_v, sigma_v, T, M, Ite, rand, 1, cho_matrix)

# Underlying price process paths
S = Heston_paths(S0, r, V, 0, cho_matrix)

def heston_call_mcP_1(S, K, r, T, t):
    payoff = np.maximum(0, S[-1, :] - K)
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average

for K_strike in K_strikes:
    heston_call_price = heston_call_mcP_1(S, K_strike, r, T, t)
    print(f"Strike: {K_strike}, Heston Call Option Price: {heston_call_price}")

"""12(b)"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as ss

lamb = 0.25  # Lambda of the model
mu = -0.5  # Mu
delta = 0.25  # Delta

r = 0.055  # Risk-free rate
sigma = 0.35  # Volatility
T = 3/12  # Maturity/time period (in years)
S0 = 80  # Current Stock Price

Ite = 10000  # Number of simulations (paths)
M = 50  # Number of steps
dt = T / M  # Time-step

SM = np.zeros((M + 1, Ite))
SM[0] = S0

# rj
rj = lamb * (np.exp(mu + 0.5 * delta**2) - 1)

# Random numbers
z1 = np.random.standard_normal((M + 1, Ite))
z2 = np.random.standard_normal((M + 1, Ite))
y = np.random.poisson(lamb * dt, (M + 1, Ite))

for t in range(1, M + 1):
    SM[t] = SM[t - 1] * (
        np.exp((r - rj - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * z1[t])
        + (np.exp(mu + delta * z2[t]) - 1) * y[t]
    )
    SM[t] = np.maximum(
        SM[t], 0.00001
    )  # To ensure that the price never goes below zero!

# Define the function outside the loop
def merton_call_mc(S, K, r, T, t):
    payoff = np.maximum(0, S[-1, :] - K)
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average

# Example usage
t = 0  # Current time
moneyness_values = [0.85, 0.90, 0.95, 1.0, 1.05, 1.10]

for moneyness in moneyness_values:
    K_strike = S0 / moneyness  # Calculate the strike price based on moneyness
    call_option_price = merton_call_mc(SM, K_strike, r, T, t)
    print(f"Merton Call Option Price for K={K_strike}: {call_option_price}")

"""# STEP 2

### **13.** American put and call -Heston model
"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as ss

def SDE_vol(v0, kappa, theta, sigma, T, M, Ite, rand, row, cho_matrix):
    dt = T / M  # T = maturity, M = number of time steps
    v = np.zeros((M + 1, Ite), dtype=np.float64)
    v[0] = v0
    sdt = np.sqrt(dt)  # Sqrt of dt
    for t in range(1, M + 1):
        ran = np.dot(cho_matrix, rand[:, t])
        v[t] = np.maximum(
            v[t - 1]
            + kappa * (theta - np.maximum(v[t - 1], 0)) * dt
            + np.sqrt(np.maximum(v[t - 1], 0)) * sigma * ran[row] * sdt,
            0  # Ensure volatility is non-negative
        )
    return v

def Heston_paths(S0, r, v, row, cho_matrix):
    S = np.zeros((M + 1, Ite), dtype=np.float64)
    S[0] = S0
    sdt = np.sqrt(dt)
    for t in range(1, M + 1, 1):
        ran = np.dot(cho_matrix, rand[:, t])
        S[t] = S[t - 1] * np.exp((r - 0.5 * v[t]) * dt + np.sqrt(v[t]) * ran[row] * sdt)

    return S

def random_number_gen(M, Ite):
    rand = np.random.standard_normal((2, M + 1, Ite))
    return rand

def american_option_mc(S, K, r, T, t, option_type='call'):
    payoff = np.maximum(0, K - S[-1, :]) if option_type == 'put' else np.maximum(0, S[-1, :] - K)
    option_value = np.maximum(payoff, 0)  # Initialize option value at maturity

    for i in range(M - 1, 0, -1):
        discount_factor = np.exp(-r * (i * dt))
        intrinsic_value = np.maximum(0, K - S[i, :]) if option_type == 'put' else np.maximum(0, S[i, :] - K)
        option_value = np.maximum(intrinsic_value, discount_factor * option_value)

    return np.mean(option_value)

# Parameters
v0 = 0.32
kappa_v = 1.85
theta_v = 0.045
sigma_v = 0.35
rho = -0.30
K = 80
t = 0
S0 = 80
r = 0.055
M0 = 50
T = 1
M = int(M0 * T)
Ite = 10000
dt = T / M

# Generating random numbers from standard normal
rand = random_number_gen(M, Ite)

# Covariance Matrix
covariance_matrix = np.zeros((2, 2), dtype=np.float64)
covariance_matrix[0] = [1.0, rho]
covariance_matrix[1] = [rho, 1.0]
cho_matrix = np.linalg.cholesky(covariance_matrix)

# Volatility process paths
V = SDE_vol(v0, kappa_v, theta_v, sigma_v, T, M, Ite, rand, 1, cho_matrix)

# Underlying price process paths
S = Heston_paths(S0, r, V, 0, cho_matrix)

# Calculate option prices
american_call_price = american_option_mc(S, K, r, T, 0, option_type='call')
american_put_price = american_option_mc(S, K, r, T, 0, option_type='put')

# Print results
print("American Call Option Price:", american_call_price)
print("American Put Option Price:", american_put_price)

"""13(b)"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as ss

lamb = 0.75  # Lambda of the model
mu = -0.5  # Mu
delta = 0.25  # Delta

r = 0.055  # Risk-free rate
sigma = 0.35  # Volatility
T = 3/12  # Maturity/time period (in years)
S0 = 80  # Current Stock Price

Ite = 10000  # Number of simulations (paths)
M = 50  # Number of steps
dt = T / M  # Time-step

SM = np.zeros((M + 1, Ite))
SM[0] = S0

# rj
rj = lamb * (np.exp(mu + 0.5 * delta**2) - 1)

# Random numbers
z1 = np.random.standard_normal((M + 1, Ite))
z2 = np.random.standard_normal((M + 1, Ite))
y = np.random.poisson(lamb * dt, (M + 1, Ite))

for t in range(1, M + 1):
    SM[t] = SM[t - 1] * (
        np.exp((r - rj - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * z1[t])
        + (np.exp(mu + delta * z2[t]) - 1) * y[t]
    )
    SM[t] = np.maximum(
        SM[t], 0.00001
    )  # To ensure that the price never goes below zero!

def american_call_mc(S, K, r, T, t):
    payoff = np.maximum(0, S[-1, :] - K)
    option_value = np.maximum(payoff, 0)  # Initialize option value at maturity

    for i in range(M - 1, 0, -1):
        discount_factor = np.exp(-r * (i * dt))
        intrinsic_value = np.maximum(0, S[i, :] - K)
        option_value = np.maximum(intrinsic_value, discount_factor * option_value)

    return np.mean(option_value)

def american_put_mc(S, K, r, T, t):
    payoff = np.maximum(0, K - S[-1, :])
    option_value = np.maximum(payoff, 0)  # Initialize option value at maturity

    for i in range(M - 1, 0, -1):
        discount_factor = np.exp(-r * (i * dt))
        intrinsic_value = np.maximum(0, K - S[i, :])
        option_value = np.maximum(intrinsic_value, discount_factor * option_value)

    return np.mean(option_value)

# Example usage
K = 90  # Strike price
t = 0  # Current time

# Calculate the American call and put option prices
american_call_price = american_call_mc(SM, K, r, T, t)
american_put_price = american_put_mc(SM, K, r, T, t)

# Print results
print("American Call Option Price:", american_call_price)
print("American Put Option Price:", american_put_price)

"""14 (a) Heston Model up-and-in call option
(UAI)
"""

import numpy as np
from scipy.stats import norm

# General parameters
S0 = 80
r = 0.055
sigma = 0.35
T = 3 / 12  # Time to maturity in years

# Heston model parameters
v0 = 0.032
kappa_v = 1.85
theta_v = 0.045

# Option parameters
K = 95  # Strike price
B = 95  # Barrier level

# Simulation parameters
n_simulations = 100000
n_steps = 100
dt = T / n_steps

# Function to simulate Heston model paths
def heston_paths(n_simulations, n_steps):
    np.random.seed(42)
    Z1 = np.random.randn(n_simulations, n_steps)
    Z2 = np.random.randn(n_simulations, n_steps)
    S = np.zeros((n_simulations, n_steps + 1))
    v = np.zeros((n_simulations, n_steps + 1))
    S[:, 0] = S0
    v[:, 0] = v0
    for i in range(1, n_steps + 1):
        v[:, i] = (
            v[:, i - 1]
            + kappa_v * (theta_v - np.maximum(v[:, i - 1], 0)) * dt
            + sigma * np.sqrt(np.maximum(v[:, i - 1], 0)) * np.sqrt(dt) * Z2[:, i - 1]
        )
        S[:, i] = S[:, i - 1] * np.exp(
            (r - 0.5 * np.maximum(v[:, i - 1], 0)) * dt
            + np.sqrt(np.maximum(v[:, i - 1], 0)) * np.sqrt(dt) * Z1[:, i - 1]
        )
    return S, v

# Function to calculate option payoff
def calculate_payoff(S, K, B):
    max_S = np.max(S, axis=1)
    option_payoff = np.maximum(max_S - K, 0) * (max_S >= B)
    return option_payoff

# Simulate paths
S_paths, v_paths = heston_paths(n_simulations, n_steps)

# Calculate option payoff
payoff = calculate_payoff(S_paths, K, B)

# Discounted option price
discount_factor = np.exp(-r * T)
option_price = discount_factor * np.mean(payoff)

print("European UAI call option price:", option_price)

"""####14 (b) Compare the price obtained to the one from the simple European call.

European UAI call option:
This option has a barrier level at $95. It becomes active only if the stock price reaches or exceeds this barrier level at some point before maturity.
The option payoff is calculated based on the maximum stock price over all simulation paths, provided it is above the strike price.
It offers the potential for higher profit compared to a standard European call option if the stock price hits the barrier level.


Simple European put option:
This is a standard European put option without any barrier feature.
The option payoff is calculated based on the stock price at maturity and the strike price.
It provides protection against a decline in the stock price below the strike price.

15 DAI
"""

import numpy as np

# Parameters
S0 = 100  # Current Stock Price
K = 65  # Strike price
r = 0.05  # Risk-free rate
T = 1.0  # Time to maturity
t = 0  # Current time

def merton_put_mc(S, K, r, T, t):
    # Initialize empty array to store option payoffs
    payoff = np.maximum(0, K - S[-1, :])

    # Calculate the average payoff and discount it to present value
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average

# Define the barrier level
barrier_level = 65

# Function to price European Down-and-In Put Option (DAI)
def merton_dai_put_mc(S, K, B, r, T, t):
    # Initialize empty array to store option payoffs
    payoff = np.zeros(S.shape[1])

    # Loop through each simulated path
    for i in range(S.shape[1]):
        # Check if the stock price reaches the barrier level at any point
        if np.any(S[:, i] <= B):
            # If the barrier is breached, calculate the option payoff
            payoff[i] = np.maximum(0, K - S[-1, i])
        else:
            # If the barrier is not breached, the option expires worthless
            payoff[i] = 0

    # Calculate the average payoff and discount it to present value
    average = np.mean(payoff)
    return np.exp(-r * (T - t)) * average

# Calculate the price of the European Down-and-In Put Option (DAI)
dai_put_option_price = merton_dai_put_mc(SM, K, barrier_level, r, T, 0)
print("Merton Down-and-In Put Option Price:", dai_put_option_price)

# Calculate the price of the Simple European Put Option
simple_put_option_price = merton_put_mc(SM, K, r, T, 0)
print("Merton Simple European Put Option Price:", simple_put_option_price)

# Compare the prices obtained for the DAI and Simple European Put Options
price_difference = dai_put_option_price - simple_put_option_price
print("Price Difference between DAI and Simple European Put Options:", price_difference)